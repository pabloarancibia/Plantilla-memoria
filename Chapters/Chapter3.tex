\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}


%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\section{Arquitectura general del sistema}
\label{sec:arquitecturagral}

\subsection{Funcionamiento}
\label{subsec:funcionamiento}
Como se puede observar en la figura \ref{fig:diagramafunciones}, el sistema está compuesto por nodos los cuales se utilizan para la lectura de tarjetas RFID asignadas a los repuestos de los clientes. Los datos se transmiten en una red lan local, se procesan y almacenan en un servidor con base de datos y son consultados desde la aplicación web en las terminales (\textit{PC} o \textit{smartphone}).

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.20]{./Figures/diagramafunciones.png}
	\caption{Diagrama de funciones generales.}
	\label{fig:diagramafunciones}
\end{figure}

\subsection{Diagrama de bloques}
\label{subsec:diagramabloques}
En la figura \ref{fig:diagramabloques} se representa el patrón de modelo conceptual empleado y las tecnologías que se utilizan en cada capa. Se implementó un modelo de 4 capas: 

\begin{itemize}
\item Capa de percepción.
\item Capa de transporte.
\item Capa de procesamiento.
\item Capa de aplicación.
\end{itemize}


\begin{figure}[ht]
	\centering
	\includegraphics[scale=.25]{./Figures/diagramabloques.png}
	\caption{Diagrama de bloques y tecnologías del sistema.}
	\label{fig:diagramabloques}
\end{figure}


En la capa de percepción se utilizan los nodos esp32 con lector RFID con los cuales se realiza la lectura de las tarjetas correspondientes. Una vez realizada la lectura, los datos son enviados por medio del protocolo MQTT y a traves de la red lan en la capa de transporte. 

La capa de transporte es la encargada de transmitir los mensajes por medio de los protocolos MQTT y HTTP. El broker \textit{Eclipse Mosquitto} distribuye los mensajes publicados a los subscriptores para su procesamiento.

En la capa de procesamiento se realiza la lógica del backend, la base de datos y el frontend. Se implementó un servidor central en una Raspberry Pi 4 con todos los servicios. Cada uno de los servicios está desarrollado de manera individual y fue montado en su propio contenedor de Docker. Todos los contenedores se despliegan utilizando Docker Compose.

Por último, la capa de aplicación otorga el acceso web desarrollado en el framework \textit{Ionic} para el ingreso, registro, administración y egreso de las ordenes de trabajo y también se utiliza el portal de administración de \textit{Portainer} para el monitoreo completo de Docker y del servidor.


\section{Flujo general del sistema}
\label{sec:flujogeneral}
En esta sección se explica el flujo total de las funciones del sistema desde que el usuario ingresa una nueva orden de trabajo hasta que el producto es retirado por el cliente.

Las comunicaciones y el envío de datos entre los distintos módulos del sistema se realizan en los protocolos HTTP, MQTT y MySQL. Se detallará en cada caso el protocolo utilizado.

\subsection{Ingreso de repuesto}
\label{subsec:ingresorepuesto}
En la figura \ref{fig:flujoingreso} se puede observar todos los módulos del sistema, el flujo de datos y el protocolo utilizado cuando un usuario carga una nueva orden de trabajo en el sistema.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.20]{./Figures/flujoingreso.png}
	\caption{Flujo en el ingreso de una nueva orden de trabajo.}
	\label{fig:flujoingreso}
\end{figure}
  
El flujo comienza cuando el usuario recibe el repuesto y selecciona una tarjeta RFID libre para usarla con ese repuesto. El usuario pasa la tarjeta por el nodo ubicado en la recepción y de esta manera se registra el número de tarjeta para ser utilizada. Luego el usuario carga los datos en el sistema web, dónde ya está asignada la tarjeta previamente leída, confirma los datos y estos son guardados en la base de datos. La nueva orden de trabajo tiene su número de tarjeta, los datos del cliente y el estado por defecto \textit{en espera}.

\section{Arquitectura de datos}
\label{sec:arquitecturadatos}
En la presente sección se desarrollará la arquitectura en la base de datos MySQL, el diseño y la implementación de las funciones con el ORM Sequelize.

\subsection{Diagrama de base de datos}
\label{subsec:diagramabasededatos}

En la figura \ref{fig:diagramabbdd} se representa un diagrama UML de la base de datos con sus tablas y relaciones.

Para realizar el diseño de la base de datos se realizó un análisis de los requerimientos y los casos de usos o historias de usuario, a partir de esto se inició el diagrama con las tablas principales y sus relaciones, a medida que se avanzaba en el desarrollo de la API y del sistema  se fueron añadiendo nuevas tablas y relaciones segun las necesidades. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=.15]{./Figures/diagramabbdd.png}
	\caption{Diagrama de base de datos.}
	\label{fig:diagramabbdd}
\end{figure}

\subsection{Estructura de archivos para ORM}
\label{subsec:estructuraorm}
Para el desarrollo de la base de datos se utilizó el ORM Sequelize. Como se menciona en el capítulo \ref{subsec:sequelize}, existen multiples ventajas al utilizar un ORM en vez de directamente programar la base de datos en lenguaje SQL, se tuvieron en cuenta esas ventajas a la hora de optar por realizar el desarrollo con este ORM. 

La estructura de carpetas y archivos está definida previamente por el ORM pudiendo realizar algunas personalizaciones. 

En la figura \ref{fig:estructuraorm} podemos ver la estructura implementada.

\begin{figure}[h]
	\centering
	\includegraphics[scale=.50]{./Figures/estructuraorm.png}
	\caption{Estructura de carpetas y archivos para ORM Sequelize.}
	\label{fig:estructuraorm}
\end{figure}

Dentro de la carpeta \textit{config} se definen los archivos de configuración de Sequelize y el acceso a la base de datos MySQL.

En la carpeta migrations, models y seeders se encuentran todos los archivos Javascript para las migraciones, los modelos y semillas, estos archivos se detallarán en las próximas seccciones. 

El archivo .sequelizerc sirve para definir la ubicación de los modelos, migraciones, semillas y otros archivos generados por Sequelize.


\subsection{Desarrollo de modelos y tablas}
\label{subsec:modelobasededatos}



A continuación se presentan algunos fragmentos de código fuente empleados para el desarrollo de la base de datos, siguiendo esta misma modalidad se realizaron todas las tablas de la base de datos, sus modificaciones y sus respectivas migraciones.


El siguiente código se ejecuta en la terminal de linux para crear el archivo para el modelo y el archivo para la migración de la tabla para ``Orden de trabajo". En el código se define el nombre del modelo y un atributo id. 

\begin{lstlisting}[label=cod:sequelizeclimodel,caption=Código CLI para crear modelo y migración en Sequelize.]
npx sequelize-cli model:generate --name mqtt_messages_gral --attributes id:integer
\end{lstlisting}

El siguiente código se emplea para definir el modelo completo de la tabla:

\begin{lstlisting}[caption= Código para un modelo en Sequelize.]
'use strict';
const {Model} = require('sequelize');
module.exports = (sequelize, DataTypes) => {
  class OrdenTrabajo extends Model {
    
    static associate(models) {
      //OrdenTrabajo.X pertenece a X
      OrdenTrabajo.belongsTo(models.Trabajo)
      OrdenTrabajo.belongsTo(models.Estado)
      OrdenTrabajo.belongsTo(models.Cliente)
      OrdenTrabajo.belongsTo(models.Usuario)
      OrdenTrabajo.belongsTo(models.Moto)

      //OrdenTrabajo tiene ids en la tabla Eventos_mqtt
      OrdenTrabajo.hasMany(models.Eventos_mqtt);

      //OrdenTrabajo tiene id en la tabla Tarjeta
      OrdenTrabajo.hasMany(models.Tarjeta);

      // Orden_trabjo tiene muchos Cambios de Estado N:M
      OrdenTrabajo.belongsToMany(models.Estado, {
        through: 'Registo_cambios_estado'
      })

      // Orden de trabajo tiene muchos Repuestos N:M
      OrdenTrabajo.belongsToMany(models.Repuesto, {
        through: 'Orden_Repuesto'
      })


    }
  }
  OrdenTrabajo.init({
    id: {
      allowNull: false,
      autoIncrement: true,
      primaryKey: true,
      type: DataTypes.INTEGER
    },
    precio:{
      type: DataTypes.INTEGER
    },
    entrega:{
      type: DataTypes.INTEGER
    },
    fecha_entrega_estimada:{
      type: DataTypes.DATE
    },
    detalle:{
      type: DataTypes.TEXT('long')
    },
    tarjeta:{
      type: DataTypes.STRING
    },
    ordenPapel:{
      type: DataTypes.STRING
    },
    informado:{
      type: DataTypes.BOOLEAN
    },
    is_active: {
      type: DataTypes.BOOLEAN
    },
    createdAt: {
      allowNull: false,
      type: DataTypes.DATE
    },
    updatedAt: {
      allowNull: false,
      type: DataTypes.DATE
    }
  }, {
    sequelize,
    modelName: 'OrdenTrabajo',
    tableName: 'OrdenTrabajo',
  });
  return OrdenTrabajo;
};

\end{lstlisting}

En las lineas 1 a la 4 se realizan las declaraciones de la librería y el nombre del modelo, 
luego en las lineas 6 a la 31 se definen las relaciones que tendrá el modelo, los tipos de relaciones pueden ser 1 a 1, 1 a muchos o muchos a muchos. Luego a partir de la lines 33 se definen los campos de la tabla o modelo, se definen también los atributos de los campos y el tipo de datos. En las lineas 74 y 75 se define el nombre personalizado que tendrá la tabla en la base de datos y el nombre del modelo que reconocerá el ORM. Por último en la linea 77 se retorna la Clase creada, de esta manera podrá ser utilizada en otras partes del código fuente.


\subsection{Desarrollo de migraciones}
\label{subsec:migracionesbasededatos}

Como se menciona en la sección anterior, el archivo con la estructura inicial de migraciones se crea a traves del CLI de Sequelize al momento de crear el modelo para una tabla, luego hay que personalizar esta estructura para que quede igual al modelo definido previamente. 

A continuación se representa el código \textit{javascript} para la migración del modelo ``Orden de trabajo":

\begin{lstlisting}[caption= Código para migración en Sequelize.]
'use strict';
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable('OrdenTrabajo', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      nombre: {
        type: Sequelize.STRING
      },
      precio:{
        type: Sequelize.INTEGER
      },
      entrega:{
        type: Sequelize.INTEGER
      },
      fecha_entrega_estimada:{
        type: Sequelize.DATE
      },
      detalle:{
        type: Sequelize.TEXT('long')
      },
      tarjeta:{
        type: Sequelize.STRING
      },
      ordenPapel:{
        type: Sequelize.STRING
      },
      informado:{
        type: Sequelize.BOOLEAN,
        defaultValue:false
      },
      TrabajoId:{
        type: Sequelize.INTEGER,
        references:{model:'Trabajo', key:'id'}
      },
      EstadoId:{
        type: Sequelize.INTEGER,
        references:{model:'Estado', key:'id'}
      },
      ClienteId:{
        type: Sequelize.INTEGER,
        references:{model:'Cliente', key:'id'}
      },
      
      UsuarioId:{
        type: Sequelize.INTEGER,
        references:{model:'Usuario', key:'id'}
      },
      MotoId:{
        type: Sequelize.INTEGER,
        references:{model:'Moto', key:'id'}
      },
      is_active: {
        type: Sequelize.BOOLEAN,
        defaultValue: true,
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable('OrdenTrabajo');
  }
};
\end{lstlisting}

Como se puede notar, el código es muy parecido al del modelo, con la diferencia que en este caso, ademas de los campos y sus atributos, sólo se deben definir directamente las claves que representan a las relaciones 1 a muchos que tendrá esta tabla, dejando de lado el resto de relaciones. 

Otra de las particularidades principales del archivo de migración es que contiene dos funciones que se ejecutan de manera asíncrona, la función up y down, la primera creará la tabla y la segunda se ejecuta en caso de alguna falla y elimina la tabla. 
  

\subsection{Interacción con la base de datos}
\label{subsec:interaccionbasededatos}

En Sequelize se pueden realizar todas las funciones necesarias para interactuar con la base de datos, ya sea para insertar, actualizar o eliminar registros, como así también los métodos para leer registros utilizando filtros o condiciones particulares.

A continuación se representan a modo de ejemplo algunos fragmentos de código Javascript empleados para tal fin:

Código para traer todas las órdenes de trabajo existentes, incluyendo otros modelos relacionados a este:

\begin{lstlisting}[caption= Código para traer datos en Sequelize.]
/**
 * 
 * @method getOrdenesTrabajo 
 * @description
 * Traer todas las ordenes de trabajo existentes
 * @returns
 * listado de todas las ordenes de trabajos existentes
 */
const getOrdenesTrabajo = async (req, res)=>{
    const ordenesTrabajo = await OrdenTrabajo.findAll({
        include:[
            {model:Cliente},
            {model: Estado},
            {model: Moto},
            {model: Trabajo},
            {model: Usuario},
        ]
    });
    return res.json(ordenesTrabajo)
}
\end{lstlisting}

En el siguiente código se representa de manera resumida cómo crear un nuevo registro, se quitaron algunas partes del código que son relevantes a esta sección:

\begin{lstlisting}[label=cod:nuevoregistro,caption=Código resumido para crear nuevo registro en la base de datos.]
/**
 * Crear nueva orden de trabajo
 */
const nuevaOrdenTrabajo = async (req,res) => {
        const nuevaOrdenTrabajo = await OrdenTrabajo.create(
            req.body, 
            );
  

        return res.json(nuevaOrdenTrabajo);
        
    } catch (error) {
        return res.status(400).json({
            error:error.message, 
            message:'Error cargando orden',
            context: 'api > controllers > ordenTrabajoController > nuevaOrdenTrabajo'
        })  
    }
    
}
\end{lstlisting}

En las lineas 5 y 6 es dónde se realiza la creación del registro, pasándole los datos que se reciben como parámetros en el \textit{body} de la petición HTTP.

Por último se muestra cómo actualizar un registro de la base de datos, previamente trayendo el objeto por su id:

\begin{lstlisting}[label=cod:updateregistro,caption=Código resumido para actualizar un registro en la base de datos.]

// Traigo la Orden de trabajo
let orden = await OrdenTrabajo.findOne({
            where: {
                id:req.params.id_orden,
                }
            });
            
// Modifico estado, precio, detalle y entrega de la Orden
        await orden.update(
            {
                EstadoId : estado.id,
                precio: req.body.precio,
                entrega: req.body.entrega,
                detalle: req.body.detalle
            });
\end{lstlisting}

Podemos observar que en la linea 3 se busca el registro mediante su id y se guarda el mismo en una variable, luego se utiliza esa variable para realizar la actualización de los datos, por lo que esa variable pasa a ser un ``objeto de Sequelize" que puede ser tratado directamente como entidad única de la base de datos, facilitando su uso mediante el ORM.


\section{Desarrollo API REST}
\label{sec:arquitecturaapirest}

La lógica del backend se centra principalmente en la API REST desarrollada, en la misma se utilizaron diferentes tecnologías las cuales están descriptas en el capítulo \ref{sec:backend}.

A continuación se detalla su desarrollo e implementación.

\subsection{Patrón de desarrollo}
\label{subsec:apipatron}

Se implementó una arquitectura de software orientada a eventos, nativa de Node.js, y la organización modular del código también llamado \textit{``event-driven"}.

En la organización modular se estructura el código de la aplicación en pequeñas piezas reutilizables. Esto hace que el código sea más fácil de mantener y actualizar a medida que la aplicación crece y evoluciona.

En la figura \ref{fig:apiestructura} se presenta la estructura de carpetas utilizada siguiendo el modelo mencionado. 

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.50]{./Figures/api-estructura-archivos.png}
	\caption{Estructura de carpetas en patrón de desarrollo modular.}
	\label{fig:apiestructura}
\end{figure}

Dentro de cada una de las carpetas se encuentran los archivos Javascript correspondientes. El archivo \textit{server.js} es el punto de partida de la API y donde se realizan las configuraciones de conexión a bases de datos con Sequelize, configuración de Express, se definen los puertos a utilizar, la conexión MQTT, se declaran las rutas o \textit{routes}, entre otras configuraciones.

En el archivo \textit{package.json} se encuentran configuraciones y datos fundamentales para la aplicación, entre estas están: el nombre de la aplicación, la versión, descripción del proyecto, los scripts de inicio y ejecución, las dependencias del proyecto, bibliotecas y paquetes de terceros utilizados, las versiones específicas de las dependencias requeridas y la información de licencia. En este archivo se define, por ejemplo, el uso de Sequelize y Express y sus respectivas versiones.

El archivo .env es un archivo que no se versiona, esto significa que no se resguarda el historial de cambios del archivo, esto se debe a que contiene información sensible que debe mantenerse segura y no debe versionarse ni subirse a internet. En cada entorno dónde la aplicación sea instalada se deberá crear este archivo manualmente y escribir las definiciones de manera manual. Se declara, por ejemplo, usuario y contraseña para la conexión a base de datos, credenciales para conexión a \textit{broker} MQTT, direcciones IP o URL, conexión a Wi-Fi, entre otros datos sensibles.

En las siguientes secciones se detallan las carpetas \textit{routers} y \textit{controllers}.

\subsection{Ruteo de la API}
\label{subsec:apirouters}

En la carpeta \textit{routers} se encuentran los archivos Javascript que corresponden a las rutas que manejará Express para recibir las peticiones o \textit{requests} HTTP provenientes desde fuera de la API, generalmente desde el cliente \textit{frontend}.

En la figura \ref{fig:apiroutes} se muetran los archivos de ruteo que se crearon siguiendo el patrón modular, separando las rutas según su entidad o funcionalidad.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.50]{./Figures/api-routes.png}
	\caption{Estructura de archivos en carpeta de rutas.}
	\label{fig:apiroutes}
\end{figure}

En el archivo \textit{ordentrabajoRouter.js} se manejan las peticiones a rutas referentes a las órdenes de trabajo, de la misma manera para los demás archivos. 

A modo de ejemplo se representa un fragmento de código de ruteo correspondientes a órdenes de trabajo:


\begin{lstlisting}[label=cod:routesot,caption=Código de ruteo para órdenes de trabajo.]
    /**
     * Nueva orden de trabajo
     * @params data, estado = espera
     * Recibe datos para la orden de trabajo
     * incluido el numero de tarjeta rfid
     */
    ordentrabajoRouter.post('/nueva',
        ordentrabajoCtrl.nuevaOrdenTrabajo);
\end{lstlisting}

En la declaración de esta ruta podemos observar que la dirección de la ruta en cuestión es \textit{/nueva} y se define con el método \textit{post()} en un objeto de router llamado \textit{ordentrabajoRouter}. Este método indica que la ruta es accesible mediante una solicitud HTTP POST, que es utilizada para enviar información a un servidor para crear un recurso.

Además, se especifica un controlador de ruta \textit{(handler)}. El controlador es una función que se ejecuta cuando se realiza una solicitud HTTP a la ruta especificada. En este caso, el controlador de ruta se llama \textit{nuevaOrdenTrabajo} y se define en el archivo \textit{ordentrabajoCtrl}, más adelante veremos en profundidad la carpeta \textit{controllers} y sus características.

Cuando se realiza una solicitud HTTP POST a la ruta \textit{/nueva}, Express ejecutará automáticamente la función \textit{nuevaOrdenTrabajo} definida en el controlador de ruta \textit{ordentrabajoCtrl}.

De esta manera se logra separar la lógica de ruteo de la lógica de procesos y acceso a datos, siguiendo el patrón modular mencionado previamente.

\subsection{Controladores de la API}
\label{subsec:apicontrollers}

Como se mencionó en la sección previa, los controladores son funciones que se ejecutan luego de resolver la ruta a la cual están asociados. 

En la figura \ref{fig:apicontrollers} se puede ver como en la carpeta \textit{controllers} se definieron los controladores siguiendo el patrón modular de desarrollo, teniendo encuenta la entidad o la funcionalidad que se desea procesar.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.50]{./Figures/api-controllers.png}
	\caption{Estructura de archivos en la carpeta \textit{controllers}.}
	\label{fig:apicontrollers}
	
\end{figure}

A modo de ejemplo se muestra a continuación un fragmento de código del controlador para obtener un listado de todas las motos de la base de datos:

\begin{lstlisting}[label=cod:routesot,caption=Código de controlador para obtener listado de motos.]
const {Moto} = require('../database/models/index');

const { Op, Sequelize } = require("sequelize");
const { response } = require('express');

//controller
const listarMoto = async (req, res)=>{
    try {
        const listadoMotos = await Moto.findAll({});
        
        return res.status(200).json({
            listadoMotos
        }); 

    } catch (error) {
        return res.status(400).json({
            error: error.message,
            message: 'Error listando motos'
        })
    }
    
};
\end{lstlisting}

La primera línea del código importa el modelo \textit{Moto} desde el archivo principal para los modelos de Sequelize \textit{index.js} ubicado en la carpeta \textit{models}. En la segunda línea, se importan las funciones \textit{Op y Sequelize} desde la librería Sequelize, estas funciones se utilizan para realizar operaciones y consultas en la base de datos. Luego, se define el controlador \textit{listarMoto} que se encarga de listar todas las motos de la base de datos. Dentro del controlador, se utiliza el método \textit{findAll()} de Sequelize para buscar todos los registros. Si la consulta a la base de datos se realiza con éxito, se devuelve un objeto \textit{JSON} con el listado de motos y un código de estado HTTP 200. En caso de que la consulta falle, se devuelve un objeto \textit{JSON} con el mensaje de error y un código de estado HTTP 400.

Finalmente, se exporta el controlador \textit{listarMoto} para que pueda ser utilizado en otras partes de la aplicación.

De manera similar se desarrollaron todos los controladores para las diferentes rutas de la aplicación. 

\subsection{Endpoints HTTP}
\label{subsec:apiendpointshttp}

Para la organización del desarrollo se realizó una tabla con todos los datos necesarios para los \textit{endpoints} o rutas de la API. 

En la figura \ref{fig:apiendpoints} se puede apreciar una parte de esta tabla correspondiente a las rutas para las órdenes de trabajo.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.40]{./Figures/api-endpoints.png}
	\caption{Tabla descriptiva de \textit{endpoints} o rutas de la API.}
	\label{fig:apiendpoints}
	
\end{figure}

A medida que se avanzó en el desarrollo se fueron marcando en verde las casillas de las rutas finalizadas, además se fue agregando más detalles o parámetros según requerimientos o necesidades.

\section{Comunicación MQTT}
\label{sec:mqttarquitectura}


\subsection{Diagrama MQTT}
\label{subsec:mqttdiagrama}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.25]{./Figures/mqtt-funciones.png}
	\caption{Diagrama de funciones MQTT.}
	\label{fig:mqttfunciones}
	
\end{figure}

En la figura \ref{fig:mqttfunciones} se pueden apreciar los distintos actores que intervienen en la comunicación MQTT del sistema. Los nodos RFID representan a cada ESP32 con el módulo lector RC522 mencionados en el capítulo \ref{subsec:esp32}, estos se encargan de marcar el estado específico de una órden de trabajo. En el centro se ubica el broker Mosquitto el cual se encarga de la distribución de los mensajes a los demás módulos y a la derecha está la API REST desarrollada en Node.js la cual recibe los mensajes provenientes de los nodos y realiza el proceso correspondiente, además de enviar publicaciones a modo de información y para \textit{logs}.

\subsection{Topics MQTT}
\label{subsec:mqtttopics}

Como se observa en la figura \ref{fig:mqtttopics}, se organizan los \textit{topics} MQTT en una tabla, en este caso, según el nodo o sensor y podemos ver en la cabecera de la tabla la información que representaremos para cada mensaje, el \textit{topic}, si es una publicación o subscripción, el mensaje en cuestión y una breve explicación de cual es la función que cumple la comunicación.

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.30]{./Figures/mqtt-topics.png}
	\caption{Tabla de \textit{topics} MQTT.}
	\label{fig:mqtttopics}
	
\end{figure}

\subsection{Broker MQTT}
\label{subsec:mqttbroker}

Para la implementación en el servidor del sistema en la Raspberry Pi del \textit{broker} MQTT ``Eclipse Mosquitto" se utilizó un servicio de Docker Compose el cual permite levantar el \textit{broker} y sus configuraciónes.

En la figura \ref{fig:mqttestructuracarpetas} podemos observar la estructura de carpetas y archivos que se implementa en el contenedor de Docker para este servicio. 

\begin{itemize}
	\item En la carpeta \textit{data} se encuentra el archivo de base de datos \textit{mosquitto.db} donde se pueden persistir los mensajes MQTT según la configuración de persistencia implementada.
	\item En la carpeta \textit{etc} se encuentra el archivo de configuración principal del \textit{broker}: \textit{mosquitto.conf}, aquí se declaran todos los parámetros con los cuales Docker Compose levantará el servicio. El archivo \textit{mqttusers} persiste de manera encriptada las credenciales de acceso para los clientes MQTT, estos usuarios son administrados por linea de comando en la terminal \textit{bash} ingresando al contenedor específico. Por último se agregó un archivo con el ejemplo de comandos para administrar usuarios: \textit{mqttusers.example}.
	\item La carpeta \textit{log} contiene el archivo \textit{mosquitto.log} donde se registran todos los logs del servicio y que sirven para hacer un \textit{debug} o \textit{test} del mismo.	
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.60]{./Figures/mqtt-estructura-carpetas.png}
	\caption{Estructura de carpetas del servicio Ecplipse Mosquitto en Docker.}
	\label{fig:mqttestructuracarpetas}
\end{figure}

\subsection{MQTT en nodos}
\label{subsec:mqttnodos}
Para implementar las comunicaciones MQTT en los nodos ESP32 se utilizó la biblioteca de código abierto PubSubClient \citep{WEBSITE:pubsubclient} la cual permite conexiones con servidores MQTT, publicar mensajes y suscribirse a los mensajes recibidos.

Como se describió en el capítulo \ref{Chapter1} Cada nodo representa uno o más estados específicos en la cadena de procesos que se realizan en la empresa. Estos estados son declarados en el código fuente del microcontrolador ESP32, específicamente en un archivo de entorno, de manera que pueda ser modificado fácilmente en caso de ser necesario.

A continuación se describen los nodos y sus estados utilizados:

\begin{itemize}
\item Nodo 1, ``mostrador``: este nodo cumple la función comunicar a la API REST por medio de MQTT el número de tarjeta que ha sido leída en el mostrador de atención a clientes de la empresa. De esta manera la API REST se encargará de asignar los estados ``espera`` o ``retirado`` a las órdenes de trabajo según corresponda.

\item Nodo 2, ``proceso``: este nodo se encarga de comunicar a la API REST que debe cambiar el estado de la órden de trabajo a ``proceso``, la API REST reconoce que el mensaje proviene de este nodo por el ``topic`` por el cual se envía el mensaje, y consulta a la base de datos qué órden de trabajo tiene el número de tarjeta recibida para ejecutar la actualización.

\item Nodo 3, ``finalizado``: de la misma manera que en el nodo 2, en este sensor se informa a la API REST que debe cambiar el estado de la órden de trabajo asociada a la tarjeta leída a ``finalizado``.
\end{itemize}

De esta manera el ciclo de lecturas de los nodos para una órden de trabajo es el siguiente: 

\begin{enumerate}
\item Nodo ``mostrador``, se asigna el estado ``espera``.
\item Nodo ``proceso``, se asigna el estado ``proceso``.
\item Nodo ``finalizado``, se asigna el estado ``finalizado``.
\item Nodo ``mostrador``, se asigna el estado ``retirado``.
\end{enumerate}



\subsection{MQTT en API REST}
\label{subsec:mqttapi}

Se definió en la estructura de la API REST, descripta en el capítulo \ref{subsec:apipatron}, una sóla ruta de entrada en el archivo principal de configuración \textit{server.js}, dónde se realiza la conexión al \textit{broker} MQTT y se subscribe a todos los \textit{topics} utilizando para ello el símbolo \#. 

Configuración y conexión a \textit{broker} MQTT:
\begin{lstlisting}[label=cod:mqttapiconect,caption= Configuración y conexión a \textit{broker} MQTT en API REST.]
 // mqtt config
    const mqtt = require('mqtt')
    const host = process.env.MQTT_SERVER
    const port = process.env.MQTT_PORT
    const clientId = `api_mqtt_${Math.random().toString(16).slice(3)}`
    
    // mqtt connect function
    const connectUrl = `mqtt://${host}:${port}`
    const mqtt_client = mqtt.connect(connectUrl, {
      clientId,
      clean: true,
      connectTimeout: 4000,
      username: process.env.MQTT_USER,
      password: process.env.MQTT_PASSWORD,
      reconnectPeriod: 3000,
    })
\end{lstlisting}

Como se puede observar en el código \ref{cod:mqttapiconect} se traen la mayoría de los parámetros desde las variables de entorno, esto se realiza para mantener un código limpio y que sea fácil de mantener, en caso de requerir algún cambio se realiza directamente en el archivo de variables de entorno evitando tener que cambiar en varias partes del código.

Primero se importa la librería MQTT y se definen las variables correspondientes al \textit{host} y puerto del \textit{broker}, así como un \textit{clientId} generado aleatoriamente. Luego se define la función de conexión al \textit{broker}, utilizando la URL compuesta por el \textit{host} y \textit{puerto} definidos anteriormente, y se especifican las opciones de conexión, incluyendo el \textit{clientId} generado, la limpieza de sesión en la conexión, un tiempo de espera de conexión de 4 segundos, el nombre de usuario y contraseña para la conexión, y un período de reconexión de 3 segundos.


Subscripción a todos los \textit{topics}:

\begin{lstlisting}[label=cod:mqttapisub,caption=Subscripción a \textit{topics} en API REST.]
// subscribe to topics
    const topic = process.env.MQTT_TOPIC_ALL;
    mqtt_client.on('connect', () => {
      console.log('mqtt client Connected')
      mqtt_client.subscribe([topic], () => {
        console.log(`API Subscribe to topic '${topic}'`)
      })
    })
\end{lstlisting}

En el código \ref{cod:mqttapisub}, en la linea 2 se trae desde las variables de entorno el \textit{topic} correspondiente. Luego se inicia la conexión con el método \textit{on} y se realiza la subscripción con el método \textit{subscribe}. 

Luego los mensajes se rutean a un controlador MQTT que procesa todos los mensajes y siguiendo un flujo condicional realiza las acciones correspondientes.

A continuación se presenta un diagrama del flujo del código fuente para resolver los procesos según el mensaje MQTT recibido:

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.50]{./Figures/mqtt-controller-api.png}
	\caption{Flujo de código fuente para MQTT en API REST.}
	\label{fig:mqttcontrollerapi}
\end{figure}

Como puede observarse en la figura \ref{fig:mqttcontrollerapi} las validaciones dependen tanto del \textit{topic} recibido como del estado de la tarjeta. De acuerdo a eso se realizan los procesos correspondientes y se devuelve siempre un mensaje MQTT al nodo emisor el cual, de acuerdo al mensaje recibido, emitira una señal sonora a travez del \textit{buzzer} para informar al usuario si la acción tuvo éxito o no.

En la figura \ref{fig:mqttsonidosnodos} se puede observar como se implementaron las señales sonoras en los nodos para informar al usuario sobre el estado de procesosy errores. Además podemos ver que existen dos opciones de sonidos, una es en forma de una sola nota denominada en la tabla \textit{Sonidos Clásicos} y otra es en forma de una melodía conocida denominada \textit{Melodías}. Se configura en cada nodo la opción deseada desde las variables de entorno. Además se realiza en el código una validación para asegurarse que el tipo de \textit{buzzer} instalado es compatible con la opción \textit{Melodía}, en caso que no lo sea se ejecuta directamente la opción \textit{Sonidos Clásicos}

\begin{figure}[ht]
	\centering
	\includegraphics[scale=.40]{./Figures/mqtt-sonidos-nodos.png}
	\caption{Tabla de detalles de sonidos de nodos.}
	\label{fig:mqttsonidosnodos}
\end{figure}


\section{API para mensajería}
\label{sec:apimessenger}

Para el envío de mensajes por la aplicación \textit{WhatsApp} \cite{whatsapp} se utilizó una API adicional \cite{api-whatsapp-ts} la cual fue personalizada para las necesidades de este sistema.

En esta sección se detalla como se implementó una API de mensajería para \textit{WhatsApp}.

Esta API permite al usuario de la aplicación conectarse a \textit{WhatsApp} con su teléfono móvil y enviar mensajes desde la aplicación a los clientes de manera automática.

\subsection{Implementación}
\label{subsec:apimessengerimplementación}

Para implementar está API se creo un conenedor en Docker de manera tal de separar este servicio del resto de los demás siguiendo una arquitectura de tipo microservicios \cite{microservices-docs}.

El patrón de desarrollo es similar al de la API REST detallada en el capitulo \ref{sec:arquitecturaapirest} y también está desarrollada en Node.js y Express, por lo que su personalización fue sensilla para este trabajo.

Se modificó el código fuente de la API para poder autenticarse desde el frontend al servicio de \textit{WhatsApp}, haciendo que el frontend pueda realizar una petición por medio del protocolo HTTP y que la API devuelva un código QR \cite{qr-code} en formato SGV \cite{svg-format} para que el usuario pueda realizar la conexión. 

En el ruteo del proyecto se añadió un endpoint para obtener un codigo QR de autenticación:

\begin{lstlisting}[label=cod:apimessengerroute,caption=Endpoint para obtener código QR.]
router.get("/", leadCtrl.getQrCode);
router.get("/regenerateqr", leadCtrl.regenerateQrCode);
\end{lstlisting}

Luego en el controlador se realiza la lógica correspondiente:

\begin{lstlisting}[label=cod:apimessengercontroller,caption=Controlador de ruta para obtener código QR.]
  public getQrCode = async(req: Request,res: Response)=>{
    const path = `${process.cwd()}/tmp`;
    res.setHeader('Content-Type', 'image/svg+xml');
    res.sendFile(`${path}/qr.svg`);
  }

  public regenerateQrCode = async(req: Request,res: Response)=>{
    console.log("logout test");
    const response = await this.leadCreator.logoutSrv();
    res.send(response);
  }
\end{lstlisting}

La primera función, llamada \textit{getQrCode}, es un controlador que se encarga de mostrar el código QR para autenticar la sesión de \textit{WhatsApp} en la aplicación. Para hacerlo, el código utiliza la función \textit{res.sendFile()} para enviar el archivo \textit{qr.svg} que se encuentra en la carpeta \textit{tmp} del directorio actual del proyecto. Además, se establece el encabezado de respuesta \textit{Content-Type} a \textit{image/svg+xml} para indicar que se está enviando un archivo SVG.

La segunda función, llamada \textit{regenerateQrCode}, es otro controlador que se encarga de cerrar la sesión de \textit{WhatsApp} actual y volver a generar un nuevo código QR. Para hacerlo, se llama a una función \textit{logoutSrv()} que se encuentra en la clase \textit{leadCreator}. Luego, se envía la respuesta al cliente con la respuesta recibida de la función \textit{logoutSrv()}.


\section{Desarrollo frontend}
\label{sec:secarquitecturafrontend}
Para el desarrollo de las interfaces de usuario se utilizó el framework Ionic \cite{WEBSITE:ionic}, implementando de esta manera el lenguaje Javascript tanto en el \textit{backend} como en el \textit{frontend}.

\subsection{Patrón de desarrollo}
\label{subsec:frontpatron}

Se implementó el patrón de diseño MVC \citep{mvc} \textit{(Modelo-Vista-Controlador)} para estructurar la aplicaciones web. Este patrón divide la aplicación en tres capas principales: el modelo, el cual representa los datos y la lógica de negocio, la vista, que representa las interfaces de usuario, y el controlador, que actúa como intermediario entre la vista y el modelo.

También se hizo uso de otros patrones de diseño, como el patrón de ``Inyección de Dependencias`` \citep{dependency-injection} \textit{Dependency Injection Pattern} y el patrón de ``Observador`` \citep{observer-pattern} \textit{Observer Pattern}. Estos patrones son utilizados para mejorar la escalabilidad, la flexibilidad y la mantenibilidad de las aplicaciones desarrolladas con Ionic.

En la capa de la vista se utilizaron las páginas, componentes y módulos de Ionic. Las páginas son plantillas en HTML o lenguaje IONIC. Los componentes son elementos visuales que se desarrollan en lenguajes HTML, CSS y Javascript y son implementados en las páginas. Los módulos son grupos de páginas y componentes. 

En la capa de controlador se utilizó un archivo Javascript con las funciones y la lógica para cada componente, dándole funcionalidad al mismo. 

En la capa de modelo se implementaron los servicios de Ionic, estos son clases que contienen métodos y lógica de negocio para recuperar datos de la API. 

Además se utilizó el manejo de rutas para mapear las URL a las páginas. Se asignó a cada módulo un archivo de rutas independiente para el manejo fluido de las mismas.

A continuación se representa un ejemplo para el desarrollo del módulo de listar órdenes de trabajo implementando este patrón:



\subsection{Interfaces de usuario}
\label{subsec:frontinterfaces}















% La idea de esta sección es resaltar los problemas encontrados, los criterios utilizados y la justificación de las decisiones que se hayan tomado.

% Se puede agregar código o pseudocódigo dentro de un entorno lstlisting con el siguiente código:

% \begin{verbatim}
% \begin{lstlisting}[caption= "un epígrafe descriptivo"]
% 	las líneas de código irían aquí...
% \end{lstlisting}
% \end{verbatim}

% A modo de ejemplo:

% \begin{lstlisting}[label=cod:vControl,caption=Pseudocódigo del lazo principal de control.]  % Start your code-block

% #define MAX_SENSOR_NUMBER 3
% #define MAX_ALARM_NUMBER  6
% #define MAX_ACTUATOR_NUMBER 6

% uint32_t sensorValue[MAX_SENSOR_NUMBER];		
% FunctionalState alarmControl[MAX_ALARM_NUMBER];	//ENABLE or DISABLE
% state_t alarmState[MAX_ALARM_NUMBER];						//ON or OFF
% state_t actuatorState[MAX_ACTUATOR_NUMBER];			//ON or OFF

% void vControl() {

% 	initGlobalVariables();
	
% 	period = 500 ms;
		
% 	while(1) {

% 		ticks = xTaskGetTickCount();
		
% 		updateSensors();
		
% 		updateAlarms();
		
% 		controlActuators();
		
% 		vTaskDelayUntil(&ticks, period);
% 	}
% }
% \end{lstlisting}



